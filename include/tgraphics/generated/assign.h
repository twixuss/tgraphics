state->_set_vsync = [](State *_state, bool enable) -> void { return ((StateGL *)_state)->impl_set_vsync(enable); };
state->_on_window_resize = [](State *_state, u32 w, u32 h) -> void { return ((StateGL *)_state)->impl_on_window_resize(w, h); };
state->_present = [](State *_state) -> void { return ((StateGL *)_state)->impl_present(); };
state->_calculate_perspective_matrices = [](State *_state, v3f position, v3f rotation, f32 aspect_ratio, f32 fov_radians, f32 near_plane, f32 far_plane) -> CameraMatrices { return ((StateGL *)_state)->impl_calculate_perspective_matrices(position, rotation, aspect_ratio, fov_radians, near_plane, far_plane); };
state->_set_blend = [](State *_state, BlendFunction function, Blend source, Blend destination) -> void { return ((StateGL *)_state)->impl_set_blend(function, source, destination); };
state->_set_topology = [](State *_state, Topology topology) -> void { return ((StateGL *)_state)->impl_set_topology(topology); };
state->_set_scissor = [](State *_state, Viewport viewport) -> void { return ((StateGL *)_state)->impl_set_scissor(viewport); };
state->_disable_scissor = [](State *_state) -> void { return ((StateGL *)_state)->impl_disable_scissor(); };
state->_set_cull = [](State *_state, Cull cull) -> void { return ((StateGL *)_state)->impl_set_cull(cull); };
state->_disable_blend = [](State *_state) -> void { return ((StateGL *)_state)->impl_disable_blend(); };
state->_disable_depth_clip = [](State *_state) -> void { return ((StateGL *)_state)->impl_disable_depth_clip(); };
state->_enable_depth_clip = [](State *_state) -> void { return ((StateGL *)_state)->impl_enable_depth_clip(); };
state->_set_viewport = [](State *_state, Viewport viewport) -> void { return ((StateGL *)_state)->impl_set_viewport(viewport); };
state->_draw = [](State *_state, u32 vertex_count, u32 start_vertex) -> void { return ((StateGL *)_state)->impl_draw(vertex_count, start_vertex); };
state->_draw_indexed = [](State *_state, u32 index_count) -> void { return ((StateGL *)_state)->impl_draw_indexed(index_count); };
state->_create_vertex_buffer = [](State *_state, Span<u8> buffer, Span<ElementType> vertex_descriptor) -> VertexBuffer * { return ((StateGL *)_state)->impl_create_vertex_buffer(buffer, vertex_descriptor); };
state->_set_vertex_buffer = [](State *_state, VertexBuffer * buffer) -> void { return ((StateGL *)_state)->impl_set_vertex_buffer(buffer); };
state->_update_vertex_buffer = [](State *_state, VertexBuffer * buffer, Span<u8> data) -> void { return ((StateGL *)_state)->impl_update_vertex_buffer(buffer, data); };
state->_create_index_buffer = [](State *_state, Span<u8> buffer, u32 index_size) -> IndexBuffer * { return ((StateGL *)_state)->impl_create_index_buffer(buffer, index_size); };
state->_set_index_buffer = [](State *_state, IndexBuffer * buffer) -> void { return ((StateGL *)_state)->impl_set_index_buffer(buffer); };
state->_create_texture_2d = [](State *_state, u32 width, u32 height, void const * data, Format format) -> Texture2D * { return ((StateGL *)_state)->impl_create_texture_2d(width, height, data, format); };
state->_set_texture_2d = [](State *_state, Texture2D * texture, u32 slot) -> void { return ((StateGL *)_state)->impl_set_texture_2d(texture, slot); };
state->_resize_texture_2d = [](State *_state, Texture2D * texture, u32 w, u32 h) -> void { return ((StateGL *)_state)->impl_resize_texture_2d(texture, w, h); };
state->_read_texture_2d = [](State *_state, Texture2D * texture, Span<u8> data) -> void { return ((StateGL *)_state)->impl_read_texture_2d(texture, data); };
state->_update_texture_2d = [](State *_state, Texture2D * texture, u32 width, u32 height, void * data) -> void { return ((StateGL *)_state)->impl_update_texture_2d(texture, width, height, data); };
state->_generate_mipmaps_2d = [](State *_state, Texture2D * texture) -> void { return ((StateGL *)_state)->impl_generate_mipmaps_2d(texture); };
state->_set_sampler = [](State *_state, Filtering filtering, Comparison comparison, u32 slot) -> void { return ((StateGL *)_state)->impl_set_sampler(filtering, comparison, slot); };
state->_create_render_target = [](State *_state, Texture2D * color, Texture2D * depth) -> RenderTarget * { return ((StateGL *)_state)->impl_create_render_target(color, depth); };
state->_set_render_target = [](State *_state, RenderTarget * target) -> void { return ((StateGL *)_state)->impl_set_render_target(target); };
state->_clear = [](State *_state, RenderTarget * render_target, ClearFlags flags, v4f color, f32 depth) -> void { return ((StateGL *)_state)->impl_clear(render_target, flags, color, depth); };
state->_create_texture_cube = [](State *_state, u32 size, void ** data, Format format) -> TextureCube * { return ((StateGL *)_state)->impl_create_texture_cube(size, data, format); };
state->_set_texture_cube = [](State *_state, TextureCube * texture, u32 slot) -> void { return ((StateGL *)_state)->impl_set_texture_cube(texture, slot); };
state->_generate_mipmaps_cube = [](State *_state, TextureCube * texture, GenerateCubeMipmapParams params) -> void { return ((StateGL *)_state)->impl_generate_mipmaps_cube(texture, params); };
state->_create_shader = [](State *_state, Span<utf8> source) -> Shader * { return ((StateGL *)_state)->impl_create_shader(source); };
state->_set_shader = [](State *_state, Shader * shader) -> void { return ((StateGL *)_state)->impl_set_shader(shader); };
state->_create_shader_constants = [](State *_state, umm size) -> ShaderConstants * { return ((StateGL *)_state)->impl_create_shader_constants(size); };
state->_update_shader_constants = [](State *_state, ShaderConstants * constants, void const * source, u32 offset, u32 size) -> void { return ((StateGL *)_state)->impl_update_shader_constants(constants, source, offset, size); };
state->_map_shader_constants = [](State *_state, ShaderConstants * constants, Access access) -> void * { return ((StateGL *)_state)->impl_map_shader_constants(constants, access); };
state->_unmap_shader_constants = [](State *_state, ShaderConstants * constants) -> void { return ((StateGL *)_state)->impl_unmap_shader_constants(constants); };
state->_set_shader_constants = [](State *_state, ShaderConstants * constants, u32 slot) -> void { return ((StateGL *)_state)->impl_set_shader_constants(constants, slot); };
state->_set_rasterizer = [](State *_state, RasterizerState state) -> void { return ((StateGL *)_state)->impl_set_rasterizer(state); };
state->_get_rasterizer = [](State *_state) -> RasterizerState { return ((StateGL *)_state)->impl_get_rasterizer(); };
state->_create_compute_shader = [](State *_state, Span<utf8> source) -> ComputeShader * { return ((StateGL *)_state)->impl_create_compute_shader(source); };
state->_set_compute_shader = [](State *_state, ComputeShader * shader) -> void { return ((StateGL *)_state)->impl_set_compute_shader(shader); };
state->_dispatch_compute_shader = [](State *_state, u32 x, u32 y, u32 z) -> void { return ((StateGL *)_state)->impl_dispatch_compute_shader(x, y, z); };
state->_create_compute_buffer = [](State *_state, u32 size) -> ComputeBuffer * { return ((StateGL *)_state)->impl_create_compute_buffer(size); };
state->_read_compute_buffer = [](State *_state, ComputeBuffer * buffer, void * data) -> void { return ((StateGL *)_state)->impl_read_compute_buffer(buffer, data); };
state->_set_compute_buffer = [](State *_state, ComputeBuffer * buffer, u32 slot) -> void { return ((StateGL *)_state)->impl_set_compute_buffer(buffer, slot); };
state->_set_compute_texture = [](State *_state, Texture2D * texture, u32 slot) -> void { return ((StateGL *)_state)->impl_set_compute_texture(texture, slot); };
